# Computer Architecture

## 컴퓨터 구성

### 하드웨어
* 중앙처리 장치: CPU
	- 명렁어의 수행 순서를 제어함
	- 명령어를 수행할 때 필요한 데이터를 처리함.
	- CPU 명령 사이클
		1. 주기억장치가 입력장치의 데이터 혹은 보조기억장치의 프로그램을 인출
		2. CPU가 주기억장치의 프로그램의 명령와 데이터를 처리
		3. 처리 결과를 다시 주기억장치에 저장
		4. 주기억장치가 처리 결과를 출력장치로 보냄
		5. 제어장치는 1 ~ 4 과정의 순서를 보장
	<br/>
		*운영체제가 64비트라면 CPU는 RAM으로부터 데이터를 64비트씩 읽어온다*
		<br/>
	* 산술논리연산장치(ALU) : 비교와 연산을 담당
	* 제어 장치: 명령어의 해석과 실행을 담당
	* 레지스터: 속도가 빠른 데이터 기억장소
		

* 기억장치: RAM, HDD, ROM
	+ 프로그램, 데이터, 연산의 중간 결과를 저장
	* 주기억장치: 실행중인 프로그램에 필요한 데이터 일시적 저장. 속도가 빠름
		- ROM(Read Only Memory): 전원이 끊어졌을 때 기록된 데이터들이 소멸되지 않는 메모리(비휘발성)
			- BIOS 같은 주요 데이터는 여기에 저장.
		- RAM(Random Access Memory): CPU가 프로그램에서 작업할 수 있도록 함. 휘발성 메모리.
			- 실행하고 있는 파일은 보조기억장치에 따로 저장함.

	* 보조기억장치: 속도가 느리지만 많은 자료를 보관할 수 있음. 데이터 영구 보관 가능
		- HDD(Hard Disk Driver): 물리적인 디스크를 고속으로 회전시켜 데이터에 저장하는 장치.
			- 충격에 약하며 소음이 발생하나 가격이 낮은 편
		- SSD(Solid State Driver): 전기적으로 데이터를 저장.
			- 속도가 빠르고 크기가 작으며 소음이 없지만 가격이 높은 편.

	* 캐시 메모리: CPU와 주기억장치 사이의 속도 차이를 완화시키기 위한 임시 메모리.
		+ ex) CPU 코어와 메모리 사이의 병목 현상 완화
		+ ex) 웹 브라우저 캐시 파일을 하드디스크와 웹페이지 사이의 병목 현상을 완화
		+ 캐시에 데이터를 저장할 때는 지역성을 최대한 활용하기 위해 해당 데이터 + 근처에 있는 데이터도 같이 가져온다.
			- 시간 지역성 : 반복문 조건 변수처럼 한 번 참조된 데이터는 또 참조될 가능성 높음
			- 공간 지역성: 연속 데이터 접근의 경우 참조 데이터 근처에 있는 데이터가 또 참조될 가능성 높음.
		+ 캐시 미스
			- cold miss: 해당 메모리를 처음 불러서 나는 미스
			- conflict miss: 데이터 여러 개가 같은 캐시 메모리 주소에 할당되어 나는 미스
			- capacity miss: 캐시 공간으로 부족해서 나는 미스
				- 캐시 크기를 키우면 접근 속도가 느려지고 파워를 많이 먹는다.

* 입출력 장치: 마우스, 프린터

### 소프트웨어
* 시스템 소프트웨어: 운영체제, 컴파일러
* 응용 소프트웨어: 워드프로세서, 스프레드시트

## 엔디언(Endianness)
컴퓨터의 메모리와 같은 1차원 공간에 여러 개의 연속된 대상을 배열하는 방법
바이트를 배열하는 방법은 _바이트 순서_(Byte Order)라고 한다.

+ 빅 엔디언 : 큰 단위가 앞에 나오는 경우 / MSB부터 차례로 저장하는 방식
	- int s = 0x12345678 => 0x12 0x34 0x56 0x78
	- 사람과 읽는 순서가 동일하여 디버깅이 편함
	- 모토로라 
+ 리틀 엔디언 : 작은 단위가 앞에 나오는 경우 / LSB부터 차례로 저장하는 방식
	- int s = 0x12345678 => 0x78 0x56 0x34 0x12
	- 하위 바이트만 사용할 때 별도의 계산이 필요없다.
	- intel x86, x64, AMD

 + 가상머신은 스택을 사용한다.
## 명령어 표현

### 실수 표현
* 이진기수법
소숫점 앞 부분은 정수변환과 동일하게 한다.
소수는 2를 곱하여 값을 뽑아낸다.
```
ex) 0.625 
0.625 * 2 = 1.25, real = 1
0.25 * 2 = 0.5, real = 0
0.5 * 2 = 1.0, real = 1
=> 위에서부터 .101

* 고정 소수점(Fixed Point)
	- 부호비트 + 정수부 + 소수부 방식
	- 소수점의 위치는 미리 정해져 있다.
	- 구현이 쉽다.
	- 표현 가능한 수의 범위가 좁은 편이라 정밀도가 떨어진다.
 ```
 ex) 7.625 = 111.101
 0000011110100000
 부호 + 정수부 + 소수부
 ```
 
* 부동 소수점(Floating Point)
	- 정규화 과정을 거쳐 부호 + 왼쪽부터 채워넣으면 된다.
	- 정규화: 정수부에 1만 남을 때까지 소수점을 왼쪽으로 이동시키고 이동한 칸 수 만큼 n에 두는 것
		- 물리학의 단위 나타내는 것과 동일
		- ex) 111.101 => 1.11101 * 2^2
		- 1은 신경 안 쓰고 표현하기도 한다. 무조건 1이기 때문.
	- 지수부의 경우 bias로 지정된 숫자를 더한 다음 넣어야 한다. n이 음수 일때도 있기 때문이다.
		- IEEE 표준에선 bias가 127이다. 즉 01000000111101이 되는 것.

### Grey Code
	- 수의 크기가 변할 때 인접한 수 사이에 한 자리만 변하게 만들어진 코드
	- 1bit만 변화하므로 하드웨어적인 오류가 적다

#### 그레이 코드 <-> 이진 코드
__XOR__
숫자가 같으면 0, 다르면 1

* 이진 -> 그레이
	1. 첫 비트는 그대로 사용
	2. 두 번째부턴 앞 비트와 XOR 한 값을 사용

* 그레이 -> 이진
	1. 첫 비트 그대로 사용
	2. 두 번째 비트부턴 전에 구한 비트와 XOR 연산한 값을 사용한다.
